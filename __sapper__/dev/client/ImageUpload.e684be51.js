import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, a as space, b as claim_element, f as children, g as detach_dev, h as claim_space, k as attr_dev, l as add_location, M as set_style, m as insert_dev, n as append_dev, N as listen_dev, L as noop, O as binding_callbacks } from './client.33602f97.js';

/* src/components/ImageUpload.svelte generated by Svelte v3.38.1 */

const file = "src/components/ImageUpload.svelte";

// (48:4) {:else}
function create_else_block(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "avatar svelte-1mv3qd3");
			if (img.src !== (img_src_value = "/images/avatar.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			add_location(img, file, 48, 6, 951);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*click_handler_1*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(48:4) {:else}",
		ctx
	});

	return block;
}

// (40:4) {#if avatar}
function create_if_block(ctx) {
	let img;
	let img_src_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "avatar svelte-1mv3qd3");
			if (img.src !== (img_src_value = /*avatar*/ ctx[0])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "d");
			add_location(img, file, 40, 6, 795);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);

			if (!mounted) {
				dispose = listen_dev(img, "click", /*click_handler*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*avatar*/ 1 && img.src !== (img_src_value = /*avatar*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(40:4) {#if avatar}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let input;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*avatar*/ ctx[0]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if_block.c();
			t = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);
			input = claim_element(div1_nodes, "INPUT", { style: true, type: true, accept: true });
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "personal_image svelte-1mv3qd3");
			add_location(div0, file, 38, 2, 743);
			set_style(input, "display", "none");
			attr_dev(input, "type", "file");
			attr_dev(input, "accept", ".jpg, .jpeg, .png");
			add_location(input, file, 57, 2, 1119);
			attr_dev(div1, "class", "personal svelte-1mv3qd3");
			add_location(div1, file, 37, 0, 718);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			if_block.m(div0, null);
			append_dev(div1, t);
			append_dev(div1, input);
			/*input_binding*/ ctx[6](input);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*change_handler*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div0, null);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if_block.d();
			/*input_binding*/ ctx[6](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ImageUpload", slots, []);
	let avatar, fileinput;

	const FileSelected = e => {
		let image = e.target.files[0];
		let reader = new FileReader();
		reader.readAsDataURL(image);

		reader.onload = e => {
			$$invalidate(0, avatar = e.target.result);
		};
	};

	const image = async () => {
		await fetch("http://localhost:8055/auth/login", {
			method: "GET",
			body: JSON.stringify({ avatar }),
			headers: {
				"Content-type": "application/json",
				Accept: "application/json"
			}
		});
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ImageUpload> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		fileinput.click();
	};

	const click_handler_1 = () => {
		fileinput.click();
	};

	const change_handler = e => FileSelected(e);

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			fileinput = $$value;
			$$invalidate(1, fileinput);
		});
	}

	$$self.$capture_state = () => ({ avatar, fileinput, FileSelected, image });

	$$self.$inject_state = $$props => {
		if ("avatar" in $$props) $$invalidate(0, avatar = $$props.avatar);
		if ("fileinput" in $$props) $$invalidate(1, fileinput = $$props.fileinput);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		avatar,
		fileinput,
		FileSelected,
		click_handler,
		click_handler_1,
		change_handler,
		input_binding
	];
}

class ImageUpload extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ImageUpload",
			options,
			id: create_fragment.name
		});
	}
}

export { ImageUpload as I };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VVcGxvYWQuZTY4NGJlNTEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0ltYWdlVXBsb2FkLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgXCIuLi9zdHlsZS9jb21wb25lbnRzL0ltYWdlVXBsb2FkLnNjc3NcIjtcbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG5sZXQgYXZhdGFyLCBmaWxlaW5wdXQ7XG5cbmNvbnN0IEZpbGVTZWxlY3RlZCA9IChlKSA9PiB7XG4gIGxldCBpbWFnZSA9IGUudGFyZ2V0LmZpbGVzWzBdO1xuICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICBhdmF0YXIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gIH07XG59O1xuY29uc3QgaW1hZ2UgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDo4MDU1L2F1dGgvbG9naW5cIiwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhdmF0YXI6IGF2YXRhcixcbiAgICB9KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgfSxcbiAgfSk7XG59O1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJwZXJzb25hbFwiPlxuICA8ZGl2IGNsYXNzPVwicGVyc29uYWxfaW1hZ2VcIj5cbiAgICB7I2lmIGF2YXRhcn1cbiAgICAgIDxpbWdcbiAgICAgICAgY2xhc3M9XCJhdmF0YXJcIlxuICAgICAgICBzcmM9XCJ7YXZhdGFyfVwiXG4gICAgICAgIGFsdD1cImRcIlxuICAgICAgICBvbjpjbGljaz1cInsoKSA9PiB7XG4gICAgICAgICAgZmlsZWlucHV0LmNsaWNrKCk7XG4gICAgICAgIH19XCIgLz5cbiAgICB7OmVsc2V9XG4gICAgICA8aW1nXG4gICAgICAgIGNsYXNzPVwiYXZhdGFyXCJcbiAgICAgICAgc3JjPVwiL2ltYWdlcy9hdmF0YXIucG5nXCJcbiAgICAgICAgYWx0PVwiXCJcbiAgICAgICAgb246Y2xpY2s9XCJ7KCkgPT4ge1xuICAgICAgICAgIGZpbGVpbnB1dC5jbGljaygpO1xuICAgICAgICB9fVwiIC8+XG4gICAgey9pZn1cbiAgPC9kaXY+XG4gIDxpbnB1dFxuICAgIHN0eWxlPVwiZGlzcGxheTpub25lXCJcbiAgICB0eXBlPVwiZmlsZVwiXG4gICAgYWNjZXB0PVwiLmpwZywgLmpwZWcsIC5wbmdcIlxuICAgIG9uOmNoYW5nZT1cInsoZSkgPT4gRmlsZVNlbGVjdGVkKGUpfVwiXG4gICAgYmluZDp0aGlzPVwie2ZpbGVpbnB1dH1cIiAvPlxuPC9kaXY+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0FrQ2MsR0FBTTs7Ozs7Ozs7Ozs7Ozt1RUFBTixHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUhYLEdBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBMUJYLE1BQU0sRUFBRSxTQUFTOztPQUVmLFlBQVksR0FBSSxDQUFDO01BQ2pCLEtBQUssR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQ3hCLE1BQU0sT0FBTyxVQUFVO0VBQzNCLE1BQU0sQ0FBQyxhQUFhLENBQUMsS0FBSzs7RUFDMUIsTUFBTSxDQUFDLE1BQU0sR0FBSSxDQUFDO21CQUNoQixNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNOzs7O09BR3RCLEtBQUs7UUFDUyxLQUFLLENBQUMsa0NBQWtDO0dBQ3hELE1BQU0sRUFBRSxLQUFLO0dBQ2IsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLEdBQ1YsTUFBTTtHQUVoQixPQUFPO0lBQ0wsY0FBYyxFQUFFLGtCQUFrQjtJQUNsQyxNQUFNLEVBQUUsa0JBQWtCOzs7Ozs7Ozs7Ozs7RUFjdEIsU0FBUyxDQUFDLEtBQUs7Ozs7RUFRZixTQUFTLENBQUMsS0FBSzs7O3dCQVFSLENBQUMsSUFBSyxZQUFZLENBQUMsQ0FBQzs7OztHQUNyQixTQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
