import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, A as validate_each_argument, P as validate_each_keys, v as validate_slots, B as Button, r as globals, e as element, t as text, a as space, b as claim_element, f as children, j as claim_text, g as detach_dev, h as claim_space, k as attr_dev, l as add_location, m as insert_dev, n as append_dev, K as group_outros, q as transition_out, F as check_outros, p as transition_in, Q as update_keyed_each, R as outro_and_destroy_block, L as noop, C as create_component, D as claim_component, E as mount_component, G as destroy_component } from './client.33602f97.js';
import { T as Title } from './Title.83727d68.js';

/* src/components/TranslationTable.svelte generated by Svelte v3.38.1 */

const { console: console_1 } = globals;
const file$1 = "src/components/TranslationTable.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (78:10) {:else}
function create_else_block_1(ctx) {
	let td;
	let t_value = /*lat*/ ctx[6].translation + "";
	let t;

	const block = {
		c: function create() {
			td = element("td");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true });
			var td_nodes = children(td);
			t = claim_text(td_nodes, t_value);
			td_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td, "class", "svelte-174brce");
			add_location(td, file$1, 78, 12, 1534);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(78:10) {:else}",
		ctx
	});

	return block;
}

// (70:10) {#if shown === lat.id}
function create_if_block_1(ctx) {
	let td;
	let span;
	let t;
	let textarea;

	const block = {
		c: function create() {
			td = element("td");
			span = element("span");
			t = space();
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true });
			var td_nodes = children(td);
			span = claim_element(td_nodes, "SPAN", { class: true, id: true });
			children(span).forEach(detach_dev);
			t = claim_space(td_nodes);
			textarea = claim_element(td_nodes, "TEXTAREA", { id: true, class: true, shown: true });
			children(textarea).forEach(detach_dev);
			td_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "canedit");
			attr_dev(span, "id", /*lat*/ ctx[6].id);
			add_location(span, file$1, 71, 14, 1299);
			attr_dev(textarea, "id", /*lat*/ ctx[6].id);
			attr_dev(textarea, "class", "translation_textarea svelte-174brce");
			attr_dev(textarea, "shown", /*shown*/ ctx[0]);
			add_location(textarea, file$1, 72, 14, 1357);
			attr_dev(td, "class", "svelte-174brce");
			add_location(td, file$1, 70, 12, 1280);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			append_dev(td, span);
			append_dev(td, t);
			append_dev(td, textarea);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*shown*/ 1) {
				attr_dev(textarea, "shown", /*shown*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(70:10) {#if shown === lat.id}",
		ctx
	});

	return block;
}

// (88:10) {:else}
function create_else_block(ctx) {
	let td;
	let button;
	let current;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[4](/*lat*/ ctx[6]);
	}

	button = new Button({
			props: { ref: "true", label: "edit" },
			$$inline: true
		});

	button.$on("click", click_handler_1);

	const block = {
		c: function create() {
			td = element("td");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true });
			var td_nodes = children(td);
			claim_component(button.$$.fragment, td_nodes);
			td_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td, "class", "svelte-174brce");
			add_location(td, file$1, 88, 12, 1814);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(button, td, null);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(88:10) {:else}",
		ctx
	});

	return block;
}

// (81:10) {#if shown === lat.id}
function create_if_block(ctx) {
	let td;
	let button;
	let current;

	button = new Button({
			props: { ref: "true", label: "Save" },
			$$inline: true
		});

	button.$on("click", /*click_handler*/ ctx[3]);

	const block = {
		c: function create() {
			td = element("td");
			create_component(button.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			td = claim_element(nodes, "TD", { class: true });
			var td_nodes = children(td);
			claim_component(button.$$.fragment, td_nodes);
			td_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td, "class", "svelte-174brce");
			add_location(td, file$1, 81, 12, 1622);
		},
		m: function mount(target, anchor) {
			insert_dev(target, td, anchor);
			mount_component(button, td, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(td);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(81:10) {#if shown === lat.id}",
		ctx
	});

	return block;
}

// (66:6) {#each translation as lat (lat.id)}
function create_each_block(key_1, ctx) {
	let tr;
	let td0;
	let t0_value = /*lat*/ ctx[6].id + "";
	let t0;
	let t1;
	let td1;
	let t2_value = /*lat*/ ctx[6].original + "";
	let t2;
	let t3;
	let t4;
	let current_block_type_index;
	let if_block1;
	let t5;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*shown*/ ctx[0] === /*lat*/ ctx[6].id) return create_if_block_1;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*shown*/ ctx[0] === /*lat*/ ctx[6].id) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			tr = element("tr");
			td0 = element("td");
			t0 = text(t0_value);
			t1 = space();
			td1 = element("td");
			t2 = text(t2_value);
			t3 = space();
			if_block0.c();
			t4 = space();
			if_block1.c();
			t5 = space();
			this.h();
		},
		l: function claim(nodes) {
			tr = claim_element(nodes, "TR", { class: true });
			var tr_nodes = children(tr);
			td0 = claim_element(tr_nodes, "TD", { class: true });
			var td0_nodes = children(td0);
			t0 = claim_text(td0_nodes, t0_value);
			td0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			td1 = claim_element(tr_nodes, "TD", { class: true });
			var td1_nodes = children(td1);
			t2 = claim_text(td1_nodes, t2_value);
			td1_nodes.forEach(detach_dev);
			t3 = claim_space(tr_nodes);
			if_block0.l(tr_nodes);
			t4 = claim_space(tr_nodes);
			if_block1.l(tr_nodes);
			t5 = claim_space(tr_nodes);
			tr_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(td0, "class", "svelte-174brce");
			add_location(td0, file$1, 67, 10, 1183);
			attr_dev(td1, "class", "svelte-174brce");
			add_location(td1, file$1, 68, 10, 1211);
			attr_dev(tr, "class", "translation_row svelte-174brce");
			add_location(tr, file$1, 66, 8, 1144);
			this.first = tr;
		},
		m: function mount(target, anchor) {
			insert_dev(target, tr, anchor);
			append_dev(tr, td0);
			append_dev(td0, t0);
			append_dev(tr, t1);
			append_dev(tr, td1);
			append_dev(td1, t2);
			append_dev(tr, t3);
			if_block0.m(tr, null);
			append_dev(tr, t4);
			if_blocks[current_block_type_index].m(tr, null);
			append_dev(tr, t5);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(tr, t4);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(tr, t5);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(tr);
			if_block0.d();
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(66:6) {#each translation as lat (lat.id)}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let section;
	let table;
	let thead;
	let tr;
	let th0;
	let t0;
	let t1;
	let th1;
	let t2;
	let t3;
	let th2;
	let t4;
	let t5;
	let th3;
	let t6;
	let t7;
	let tbody;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*translation*/ ctx[1];
	validate_each_argument(each_value);
	const get_key = ctx => /*lat*/ ctx[6].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			section = element("section");
			table = element("table");
			thead = element("thead");
			tr = element("tr");
			th0 = element("th");
			t0 = text("ID");
			t1 = space();
			th1 = element("th");
			t2 = text("Original");
			t3 = space();
			th2 = element("th");
			t4 = text("Translation");
			t5 = space();
			th3 = element("th");
			t6 = text("Action");
			t7 = space();
			tbody = element("tbody");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			table = claim_element(section_nodes, "TABLE", { class: true });
			var table_nodes = children(table);
			thead = claim_element(table_nodes, "THEAD", { class: true });
			var thead_nodes = children(thead);
			tr = claim_element(thead_nodes, "TR", { class: true });
			var tr_nodes = children(tr);
			th0 = claim_element(tr_nodes, "TH", { class: true });
			var th0_nodes = children(th0);
			t0 = claim_text(th0_nodes, "ID");
			th0_nodes.forEach(detach_dev);
			t1 = claim_space(tr_nodes);
			th1 = claim_element(tr_nodes, "TH", { class: true });
			var th1_nodes = children(th1);
			t2 = claim_text(th1_nodes, "Original");
			th1_nodes.forEach(detach_dev);
			t3 = claim_space(tr_nodes);
			th2 = claim_element(tr_nodes, "TH", { class: true });
			var th2_nodes = children(th2);
			t4 = claim_text(th2_nodes, "Translation");
			th2_nodes.forEach(detach_dev);
			t5 = claim_space(tr_nodes);
			th3 = claim_element(tr_nodes, "TH", { class: true });
			var th3_nodes = children(th3);
			t6 = claim_text(th3_nodes, "Action");
			th3_nodes.forEach(detach_dev);
			tr_nodes.forEach(detach_dev);
			thead_nodes.forEach(detach_dev);
			t7 = claim_space(table_nodes);
			tbody = claim_element(table_nodes, "TBODY", {});
			var tbody_nodes = children(tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(tbody_nodes);
			}

			tbody_nodes.forEach(detach_dev);
			table_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(th0, "class", "svelte-174brce");
			add_location(th0, file$1, 58, 8, 966);
			attr_dev(th1, "class", "svelte-174brce");
			add_location(th1, file$1, 59, 8, 986);
			attr_dev(th2, "class", "svelte-174brce");
			add_location(th2, file$1, 60, 8, 1012);
			attr_dev(th3, "class", "svelte-174brce");
			add_location(th3, file$1, 61, 8, 1041);
			attr_dev(tr, "class", "translation_items svelte-174brce");
			add_location(tr, file$1, 57, 6, 927);
			attr_dev(thead, "class", "svelte-174brce");
			add_location(thead, file$1, 56, 4, 913);
			add_location(tbody, file$1, 64, 4, 1086);
			attr_dev(table, "class", "translation borderline svelte-174brce");
			add_location(table, file$1, 55, 2, 870);
			attr_dev(section, "class", "table");
			add_location(section, file$1, 54, 0, 844);
		},
		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, table);
			append_dev(table, thead);
			append_dev(thead, tr);
			append_dev(tr, th0);
			append_dev(th0, t0);
			append_dev(tr, t1);
			append_dev(tr, th1);
			append_dev(th1, t2);
			append_dev(tr, t3);
			append_dev(tr, th2);
			append_dev(th2, t4);
			append_dev(tr, t5);
			append_dev(tr, th3);
			append_dev(th3, t6);
			append_dev(table, t7);
			append_dev(table, tbody);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(tbody, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*console, shown, translation, shownText*/ 7) {
				each_value = /*translation*/ ctx[1];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("TranslationTable", slots, []);
	let shown = false;
	let id = null;

	let translation = [
		{
			id: "1",
			original: "Hello",
			translation: "Is nog niet vertaald"
		},
		{
			id: "2",
			original: "heyhey",
			translation: "Is nog niet vertaald"
		},
		{
			id: "3",
			original: "jipla",
			translation: "Is nog niet vertaald"
		}
	];

	const shownText = id => {
		$$invalidate(0, shown = id);
	};

	console.log(translation);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<TranslationTable> was created with unknown prop '${key}'`);
	});

	const click_handler = () => console.log("gesaved");

	const click_handler_1 = lat => {
		shownText(lat.id);
	};

	$$self.$capture_state = () => ({
		Button,
		shown,
		id,
		translation,
		shownText
	});

	$$self.$inject_state = $$props => {
		if ("shown" in $$props) $$invalidate(0, shown = $$props.shown);
		if ("id" in $$props) id = $$props.id;
		if ("translation" in $$props) $$invalidate(1, translation = $$props.translation);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [shown, translation, shownText, click_handler, click_handler_1];
}

class TranslationTable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TranslationTable",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/routes/translations.svelte generated by Svelte v3.38.1 */
const file = "src/routes/translations.svelte";

function create_fragment(ctx) {
	let div1;
	let title;
	let t;
	let div0;
	let translationtable;
	let current;

	title = new Title({
			props: { text: "Translations" },
			$$inline: true
		});

	translationtable = new TranslationTable({ $$inline: true });

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(title.$$.fragment);
			t = space();
			div0 = element("div");
			create_component(translationtable.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(title.$$.fragment, div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(translationtable.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "table svelte-4r44lq");
			add_location(div0, file, 11, 2, 254);
			attr_dev(div1, "class", "p-pages");
			add_location(div1, file, 9, 0, 198);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(title, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			mount_component(translationtable, div0, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(title.$$.fragment, local);
			transition_in(translationtable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title.$$.fragment, local);
			transition_out(translationtable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(title);
			destroy_component(translationtable);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Translations", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Translations> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Title, TranslationTable });
	return [];
}

class Translations extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Translations",
			options,
			id: create_fragment.name
		});
	}
}

export default Translations;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsYXRpb25zLjlkNWJkZWNkLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9UcmFuc2xhdGlvblRhYmxlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3R5bGUgbGFuZz1cInNjc3NcIj5cbkBpbXBvcnQgXCIuLi9zdHlsZS9jb21wb25lbnRzL1RyYW5zbGF0aW9uVGFibGUuc2Nzc1wiO1xuPC9zdHlsZT5cblxuPHNjcmlwdD5cbmltcG9ydCBCdXR0b24gZnJvbSBcIi4vQnV0dG9uLnN2ZWx0ZVwiO1xubGV0IHNob3duID0gZmFsc2U7XG5cbmxldCBpZCA9IG51bGw7XG5sZXQgdHJhbnNsYXRpb24gPSBbXG4gIHtcbiAgICBpZDogXCIxXCIsXG4gICAgb3JpZ2luYWw6IFwiSGVsbG9cIixcbiAgICB0cmFuc2xhdGlvbjogXCJJcyBub2cgbmlldCB2ZXJ0YWFsZFwiLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMlwiLFxuICAgIG9yaWdpbmFsOiBcImhleWhleVwiLFxuICAgIHRyYW5zbGF0aW9uOiBcIklzIG5vZyBuaWV0IHZlcnRhYWxkXCIsXG4gIH0sXG4gIHtcbiAgICBpZDogXCIzXCIsXG4gICAgb3JpZ2luYWw6IFwiamlwbGFcIixcbiAgICB0cmFuc2xhdGlvbjogXCJJcyBub2cgbmlldCB2ZXJ0YWFsZFwiLFxuICB9LFxuXTtcblxuY29uc3Qgc2hvd25UZXh0ID0gKGlkKSA9PiB7XG4gIHNob3duID0gaWQ7XG59O1xuXG5jb25zb2xlLmxvZyh0cmFuc2xhdGlvbik7XG48L3NjcmlwdD5cblxuPHNlY3Rpb24gY2xhc3M9XCJ0YWJsZVwiPlxuICA8dGFibGUgY2xhc3M9XCJ0cmFuc2xhdGlvbiBib3JkZXJsaW5lXCI+XG4gICAgPHRoZWFkPlxuICAgICAgPHRyIGNsYXNzPVwidHJhbnNsYXRpb25faXRlbXNcIj5cbiAgICAgICAgPHRoPklEPC90aD5cbiAgICAgICAgPHRoPk9yaWdpbmFsPC90aD5cbiAgICAgICAgPHRoPlRyYW5zbGF0aW9uPC90aD5cbiAgICAgICAgPHRoPkFjdGlvbjwvdGg+XG4gICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRib2R5PlxuICAgICAgeyNlYWNoIHRyYW5zbGF0aW9uIGFzIGxhdCAobGF0LmlkKX1cbiAgICAgICAgPHRyIGNsYXNzPVwidHJhbnNsYXRpb25fcm93XCI+XG4gICAgICAgICAgPHRkPntsYXQuaWR9PC90ZD5cbiAgICAgICAgICA8dGQ+e2xhdC5vcmlnaW5hbH08L3RkPlxuICAgICAgICAgIHsjaWYgc2hvd24gPT09IGxhdC5pZH1cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjYW5lZGl0XCIgaWQ9XCJ7bGF0LmlkfVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgICAgaWQ9XCJ7bGF0LmlkfVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJ0cmFuc2xhdGlvbl90ZXh0YXJlYVwiXG4gICAgICAgICAgICAgICAgc2hvd249XCJ7c2hvd259XCI+PC90ZXh0YXJlYT5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgPHRkPntsYXQudHJhbnNsYXRpb259PC90ZD5cbiAgICAgICAgICB7L2lmfVxuICAgICAgICAgIHsjaWYgc2hvd24gPT09IGxhdC5pZH1cbiAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIHJlZj1cInRydWVcIlxuICAgICAgICAgICAgICAgIGxhYmVsPVwiU2F2ZVwiXG4gICAgICAgICAgICAgICAgb246Y2xpY2s9XCJ7KCkgPT4gY29uc29sZS5sb2coJ2dlc2F2ZWQnKX1cIiAvPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICA8dGQ+XG4gICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICByZWY9XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICBsYWJlbD1cImVkaXRcIlxuICAgICAgICAgICAgICAgIG9uOmNsaWNrPVwieygpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNob3duVGV4dChsYXQuaWQpO1xuICAgICAgICAgICAgICAgIH19XCIgLz5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgey9pZn1cbiAgICAgICAgPC90cj5cbiAgICAgIHsvZWFjaH1cbiAgICA8L3Rib2R5PlxuICA8L3RhYmxlPlxuPC9zZWN0aW9uPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQTBEaUIsR0FBRyxJQUFDLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FQUyxHQUFHLElBQUMsRUFBRTs7b0NBRTFCLEdBQUcsSUFBQyxFQUFFOzt5Q0FFSCxHQUFLOzs7Ozs7Ozs7Ozs7OzBDQUFMLEdBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFSZCxHQUFHLElBQUMsRUFBRTs7Ozt3QkFDTixHQUFHLElBQUMsUUFBUTs7Ozs7Ozs7OztnQkFDWixHQUFLLGdCQUFLLEdBQUcsSUFBQyxFQUFFOzs7Ozs7Ozs7O2dCQVdoQixHQUFLLGdCQUFLLEdBQUcsSUFBQyxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBZmxCLEdBQVc7O2dDQUFTLEdBQUcsSUFBQyxFQUFFOzs7Z0NBQS9CLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBQUMsR0FBVzs7Ozs7Ozs7Ozs7a0NBQWhCLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXZDUixLQUFLLEdBQUcsS0FBSztLQUViLEVBQUUsR0FBRyxJQUFJOztLQUNULFdBQVc7O0dBRVgsRUFBRSxFQUFFLEdBQUc7R0FDUCxRQUFRLEVBQUUsT0FBTztHQUNqQixXQUFXLEVBQUUsc0JBQXNCOzs7R0FHbkMsRUFBRSxFQUFFLEdBQUc7R0FDUCxRQUFRLEVBQUUsUUFBUTtHQUNsQixXQUFXLEVBQUUsc0JBQXNCOzs7R0FHbkMsRUFBRSxFQUFFLEdBQUc7R0FDUCxRQUFRLEVBQUUsT0FBTztHQUNqQixXQUFXLEVBQUUsc0JBQXNCOzs7O09BSWpDLFNBQVMsR0FBSSxFQUFFO2tCQUNuQixLQUFLLEdBQUcsRUFBRTs7O0NBR1osT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXOzs7Ozs7OzZCQWtDVSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVM7OztFQVFwQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
